// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: akjFont.proto

#ifndef PROTOBUF_akjFont_2eproto__INCLUDED
#define PROTOBUF_akjFont_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace sdff {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_akjFont_2eproto();
void protobuf_AssignDesc_akjFont_2eproto();
void protobuf_ShutdownFile_akjFont_2eproto();

class akjFont;
class akjFont_charData;
class akjFont_vertexData;
class akjFont_kernData;

// ===================================================================

class akjFont_charData : public ::google::protobuf::Message {
 public:
  akjFont_charData();
  virtual ~akjFont_charData();

  akjFont_charData(const akjFont_charData& from);

  inline akjFont_charData& operator=(const akjFont_charData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const akjFont_charData& default_instance();

  void Swap(akjFont_charData* other);

  // implements Message ----------------------------------------------

  akjFont_charData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const akjFont_charData& from);
  void MergeFrom(const akjFont_charData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 indx = 2;
  inline bool has_indx() const;
  inline void clear_indx();
  static const int kIndxFieldNumber = 2;
  inline ::google::protobuf::int32 indx() const;
  inline void set_indx(::google::protobuf::int32 value);

  // required float xOffset = 3;
  inline bool has_xoffset() const;
  inline void clear_xoffset();
  static const int kXOffsetFieldNumber = 3;
  inline float xoffset() const;
  inline void set_xoffset(float value);

  // required float yOffset = 4;
  inline bool has_yoffset() const;
  inline void clear_yoffset();
  static const int kYOffsetFieldNumber = 4;
  inline float yoffset() const;
  inline void set_yoffset(float value);

  // required float xAdvance = 5;
  inline bool has_xadvance() const;
  inline void clear_xadvance();
  static const int kXAdvanceFieldNumber = 5;
  inline float xadvance() const;
  inline void set_xadvance(float value);

  // @@protoc_insertion_point(class_scope:sdff.akjFont.charData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_indx();
  inline void clear_has_indx();
  inline void set_has_xoffset();
  inline void clear_has_xoffset();
  inline void set_has_yoffset();
  inline void clear_has_yoffset();
  inline void set_has_xadvance();
  inline void clear_has_xadvance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 indx_;
  float xoffset_;
  float yoffset_;
  float xadvance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_akjFont_2eproto();
  friend void protobuf_AssignDesc_akjFont_2eproto();
  friend void protobuf_ShutdownFile_akjFont_2eproto();

  void InitAsDefaultInstance();
  static akjFont_charData* default_instance_;
};
// -------------------------------------------------------------------

class akjFont_vertexData : public ::google::protobuf::Message {
 public:
  akjFont_vertexData();
  virtual ~akjFont_vertexData();

  akjFont_vertexData(const akjFont_vertexData& from);

  inline akjFont_vertexData& operator=(const akjFont_vertexData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const akjFont_vertexData& default_instance();

  void Swap(akjFont_vertexData* other);

  // implements Message ----------------------------------------------

  akjFont_vertexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const akjFont_vertexData& from);
  void MergeFrom(const akjFont_vertexData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float xPos = 1;
  inline bool has_xpos() const;
  inline void clear_xpos();
  static const int kXPosFieldNumber = 1;
  inline float xpos() const;
  inline void set_xpos(float value);

  // required float yPos = 2;
  inline bool has_ypos() const;
  inline void clear_ypos();
  static const int kYPosFieldNumber = 2;
  inline float ypos() const;
  inline void set_ypos(float value);

  // required float width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline float width() const;
  inline void set_width(float value);

  // required float height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline float height() const;
  inline void set_height(float value);

  // @@protoc_insertion_point(class_scope:sdff.akjFont.vertexData)
 private:
  inline void set_has_xpos();
  inline void clear_has_xpos();
  inline void set_has_ypos();
  inline void clear_has_ypos();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float xpos_;
  float ypos_;
  float width_;
  float height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_akjFont_2eproto();
  friend void protobuf_AssignDesc_akjFont_2eproto();
  friend void protobuf_ShutdownFile_akjFont_2eproto();

  void InitAsDefaultInstance();
  static akjFont_vertexData* default_instance_;
};
// -------------------------------------------------------------------

class akjFont_kernData : public ::google::protobuf::Message {
 public:
  akjFont_kernData();
  virtual ~akjFont_kernData();

  akjFont_kernData(const akjFont_kernData& from);

  inline akjFont_kernData& operator=(const akjFont_kernData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const akjFont_kernData& default_instance();

  void Swap(akjFont_kernData* other);

  // implements Message ----------------------------------------------

  akjFont_kernData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const akjFont_kernData& from);
  void MergeFrom(const akjFont_kernData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional int32 a = 3;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 3;
  inline ::google::protobuf::int32 a() const;
  inline void set_a(::google::protobuf::int32 value);

  // optional int32 b = 4;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 4;
  inline ::google::protobuf::int32 b() const;
  inline void set_b(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sdff.akjFont.kernData)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_b();
  inline void clear_has_b();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  ::google::protobuf::int32 a_;
  ::google::protobuf::int32 b_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_akjFont_2eproto();
  friend void protobuf_AssignDesc_akjFont_2eproto();
  friend void protobuf_ShutdownFile_akjFont_2eproto();

  void InitAsDefaultInstance();
  static akjFont_kernData* default_instance_;
};
// -------------------------------------------------------------------

class akjFont : public ::google::protobuf::Message {
 public:
  akjFont();
  virtual ~akjFont();

  akjFont(const akjFont& from);

  inline akjFont& operator=(const akjFont& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const akjFont& default_instance();

  void Swap(akjFont* other);

  // implements Message ----------------------------------------------

  akjFont* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const akjFont& from);
  void MergeFrom(const akjFont& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef akjFont_charData charData;
  typedef akjFont_vertexData vertexData;
  typedef akjFont_kernData kernData;

  // accessors -------------------------------------------------------

  // optional string fontName = 1;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontNameFieldNumber = 1;
  inline const ::std::string& fontname() const;
  inline void set_fontname(const ::std::string& value);
  inline void set_fontname(const char* value);
  inline void set_fontname(const char* value, size_t size);
  inline ::std::string* mutable_fontname();
  inline ::std::string* release_fontname();
  inline void set_allocated_fontname(::std::string* fontname);

  // optional string fontFileName = 2;
  inline bool has_fontfilename() const;
  inline void clear_fontfilename();
  static const int kFontFileNameFieldNumber = 2;
  inline const ::std::string& fontfilename() const;
  inline void set_fontfilename(const ::std::string& value);
  inline void set_fontfilename(const char* value);
  inline void set_fontfilename(const char* value, size_t size);
  inline ::std::string* mutable_fontfilename();
  inline ::std::string* release_fontfilename();
  inline void set_allocated_fontfilename(::std::string* fontfilename);

  // optional int32 texWidth = 3;
  inline bool has_texwidth() const;
  inline void clear_texwidth();
  static const int kTexWidthFieldNumber = 3;
  inline ::google::protobuf::int32 texwidth() const;
  inline void set_texwidth(::google::protobuf::int32 value);

  // optional int32 texHeight = 4;
  inline bool has_texheight() const;
  inline void clear_texheight();
  static const int kTexHeightFieldNumber = 4;
  inline ::google::protobuf::int32 texheight() const;
  inline void set_texheight(::google::protobuf::int32 value);

  // optional sint32 offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // optional float scaleFactor = 6;
  inline bool has_scalefactor() const;
  inline void clear_scalefactor();
  static const int kScaleFactorFieldNumber = 6;
  inline float scalefactor() const;
  inline void set_scalefactor(float value);

  // repeated .sdff.akjFont.charData chars = 7;
  inline int chars_size() const;
  inline void clear_chars();
  static const int kCharsFieldNumber = 7;
  inline const ::sdff::akjFont_charData& chars(int index) const;
  inline ::sdff::akjFont_charData* mutable_chars(int index);
  inline ::sdff::akjFont_charData* add_chars();
  inline const ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_charData >&
      chars() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_charData >*
      mutable_chars();

  // repeated .sdff.akjFont.vertexData vertices = 8;
  inline int vertices_size() const;
  inline void clear_vertices();
  static const int kVerticesFieldNumber = 8;
  inline const ::sdff::akjFont_vertexData& vertices(int index) const;
  inline ::sdff::akjFont_vertexData* mutable_vertices(int index);
  inline ::sdff::akjFont_vertexData* add_vertices();
  inline const ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_vertexData >&
      vertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_vertexData >*
      mutable_vertices();

  // repeated .sdff.akjFont.kernData kernPairs = 9;
  inline int kernpairs_size() const;
  inline void clear_kernpairs();
  static const int kKernPairsFieldNumber = 9;
  inline const ::sdff::akjFont_kernData& kernpairs(int index) const;
  inline ::sdff::akjFont_kernData* mutable_kernpairs(int index);
  inline ::sdff::akjFont_kernData* add_kernpairs();
  inline const ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_kernData >&
      kernpairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_kernData >*
      mutable_kernpairs();

  // optional bytes ddsData = 10;
  inline bool has_ddsdata() const;
  inline void clear_ddsdata();
  static const int kDdsDataFieldNumber = 10;
  inline const ::std::string& ddsdata() const;
  inline void set_ddsdata(const ::std::string& value);
  inline void set_ddsdata(const char* value);
  inline void set_ddsdata(const void* value, size_t size);
  inline ::std::string* mutable_ddsdata();
  inline ::std::string* release_ddsdata();
  inline void set_allocated_ddsdata(::std::string* ddsdata);

  // optional bytes fontFileData = 11;
  inline bool has_fontfiledata() const;
  inline void clear_fontfiledata();
  static const int kFontFileDataFieldNumber = 11;
  inline const ::std::string& fontfiledata() const;
  inline void set_fontfiledata(const ::std::string& value);
  inline void set_fontfiledata(const char* value);
  inline void set_fontfiledata(const void* value, size_t size);
  inline ::std::string* mutable_fontfiledata();
  inline ::std::string* release_fontfiledata();
  inline void set_allocated_fontfiledata(::std::string* fontfiledata);

  // @@protoc_insertion_point(class_scope:sdff.akjFont)
 private:
  inline void set_has_fontname();
  inline void clear_has_fontname();
  inline void set_has_fontfilename();
  inline void clear_has_fontfilename();
  inline void set_has_texwidth();
  inline void clear_has_texwidth();
  inline void set_has_texheight();
  inline void clear_has_texheight();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_scalefactor();
  inline void clear_has_scalefactor();
  inline void set_has_ddsdata();
  inline void clear_has_ddsdata();
  inline void set_has_fontfiledata();
  inline void clear_has_fontfiledata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fontname_;
  ::std::string* fontfilename_;
  ::google::protobuf::int32 texwidth_;
  ::google::protobuf::int32 texheight_;
  ::google::protobuf::int32 offset_;
  float scalefactor_;
  ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_charData > chars_;
  ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_vertexData > vertices_;
  ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_kernData > kernpairs_;
  ::std::string* ddsdata_;
  ::std::string* fontfiledata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_akjFont_2eproto();
  friend void protobuf_AssignDesc_akjFont_2eproto();
  friend void protobuf_ShutdownFile_akjFont_2eproto();

  void InitAsDefaultInstance();
  static akjFont* default_instance_;
};
// ===================================================================


// ===================================================================

// akjFont_charData

// required int32 ID = 1;
inline bool akjFont_charData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void akjFont_charData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void akjFont_charData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void akjFont_charData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 akjFont_charData::id() const {
  return id_;
}
inline void akjFont_charData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 indx = 2;
inline bool akjFont_charData::has_indx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void akjFont_charData::set_has_indx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void akjFont_charData::clear_has_indx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void akjFont_charData::clear_indx() {
  indx_ = 0;
  clear_has_indx();
}
inline ::google::protobuf::int32 akjFont_charData::indx() const {
  return indx_;
}
inline void akjFont_charData::set_indx(::google::protobuf::int32 value) {
  set_has_indx();
  indx_ = value;
}

// required float xOffset = 3;
inline bool akjFont_charData::has_xoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void akjFont_charData::set_has_xoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void akjFont_charData::clear_has_xoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void akjFont_charData::clear_xoffset() {
  xoffset_ = 0;
  clear_has_xoffset();
}
inline float akjFont_charData::xoffset() const {
  return xoffset_;
}
inline void akjFont_charData::set_xoffset(float value) {
  set_has_xoffset();
  xoffset_ = value;
}

// required float yOffset = 4;
inline bool akjFont_charData::has_yoffset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void akjFont_charData::set_has_yoffset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void akjFont_charData::clear_has_yoffset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void akjFont_charData::clear_yoffset() {
  yoffset_ = 0;
  clear_has_yoffset();
}
inline float akjFont_charData::yoffset() const {
  return yoffset_;
}
inline void akjFont_charData::set_yoffset(float value) {
  set_has_yoffset();
  yoffset_ = value;
}

// required float xAdvance = 5;
inline bool akjFont_charData::has_xadvance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void akjFont_charData::set_has_xadvance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void akjFont_charData::clear_has_xadvance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void akjFont_charData::clear_xadvance() {
  xadvance_ = 0;
  clear_has_xadvance();
}
inline float akjFont_charData::xadvance() const {
  return xadvance_;
}
inline void akjFont_charData::set_xadvance(float value) {
  set_has_xadvance();
  xadvance_ = value;
}

// -------------------------------------------------------------------

// akjFont_vertexData

// required float xPos = 1;
inline bool akjFont_vertexData::has_xpos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void akjFont_vertexData::set_has_xpos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void akjFont_vertexData::clear_has_xpos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void akjFont_vertexData::clear_xpos() {
  xpos_ = 0;
  clear_has_xpos();
}
inline float akjFont_vertexData::xpos() const {
  return xpos_;
}
inline void akjFont_vertexData::set_xpos(float value) {
  set_has_xpos();
  xpos_ = value;
}

// required float yPos = 2;
inline bool akjFont_vertexData::has_ypos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void akjFont_vertexData::set_has_ypos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void akjFont_vertexData::clear_has_ypos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void akjFont_vertexData::clear_ypos() {
  ypos_ = 0;
  clear_has_ypos();
}
inline float akjFont_vertexData::ypos() const {
  return ypos_;
}
inline void akjFont_vertexData::set_ypos(float value) {
  set_has_ypos();
  ypos_ = value;
}

// required float width = 3;
inline bool akjFont_vertexData::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void akjFont_vertexData::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void akjFont_vertexData::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void akjFont_vertexData::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float akjFont_vertexData::width() const {
  return width_;
}
inline void akjFont_vertexData::set_width(float value) {
  set_has_width();
  width_ = value;
}

// required float height = 4;
inline bool akjFont_vertexData::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void akjFont_vertexData::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void akjFont_vertexData::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void akjFont_vertexData::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float akjFont_vertexData::height() const {
  return height_;
}
inline void akjFont_vertexData::set_height(float value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// akjFont_kernData

// optional float x = 1;
inline bool akjFont_kernData::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void akjFont_kernData::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void akjFont_kernData::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void akjFont_kernData::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float akjFont_kernData::x() const {
  return x_;
}
inline void akjFont_kernData::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool akjFont_kernData::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void akjFont_kernData::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void akjFont_kernData::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void akjFont_kernData::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float akjFont_kernData::y() const {
  return y_;
}
inline void akjFont_kernData::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional int32 a = 3;
inline bool akjFont_kernData::has_a() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void akjFont_kernData::set_has_a() {
  _has_bits_[0] |= 0x00000004u;
}
inline void akjFont_kernData::clear_has_a() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void akjFont_kernData::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline ::google::protobuf::int32 akjFont_kernData::a() const {
  return a_;
}
inline void akjFont_kernData::set_a(::google::protobuf::int32 value) {
  set_has_a();
  a_ = value;
}

// optional int32 b = 4;
inline bool akjFont_kernData::has_b() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void akjFont_kernData::set_has_b() {
  _has_bits_[0] |= 0x00000008u;
}
inline void akjFont_kernData::clear_has_b() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void akjFont_kernData::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline ::google::protobuf::int32 akjFont_kernData::b() const {
  return b_;
}
inline void akjFont_kernData::set_b(::google::protobuf::int32 value) {
  set_has_b();
  b_ = value;
}

// -------------------------------------------------------------------

// akjFont

// optional string fontName = 1;
inline bool akjFont::has_fontname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void akjFont::set_has_fontname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void akjFont::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void akjFont::clear_fontname() {
  if (fontname_ != &::google::protobuf::internal::kEmptyString) {
    fontname_->clear();
  }
  clear_has_fontname();
}
inline const ::std::string& akjFont::fontname() const {
  return *fontname_;
}
inline void akjFont::set_fontname(const ::std::string& value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
}
inline void akjFont::set_fontname(const char* value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
}
inline void akjFont::set_fontname(const char* value, size_t size) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* akjFont::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  return fontname_;
}
inline ::std::string* akjFont::release_fontname() {
  clear_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fontname_;
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void akjFont::set_allocated_fontname(::std::string* fontname) {
  if (fontname_ != &::google::protobuf::internal::kEmptyString) {
    delete fontname_;
  }
  if (fontname) {
    set_has_fontname();
    fontname_ = fontname;
  } else {
    clear_has_fontname();
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fontFileName = 2;
inline bool akjFont::has_fontfilename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void akjFont::set_has_fontfilename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void akjFont::clear_has_fontfilename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void akjFont::clear_fontfilename() {
  if (fontfilename_ != &::google::protobuf::internal::kEmptyString) {
    fontfilename_->clear();
  }
  clear_has_fontfilename();
}
inline const ::std::string& akjFont::fontfilename() const {
  return *fontfilename_;
}
inline void akjFont::set_fontfilename(const ::std::string& value) {
  set_has_fontfilename();
  if (fontfilename_ == &::google::protobuf::internal::kEmptyString) {
    fontfilename_ = new ::std::string;
  }
  fontfilename_->assign(value);
}
inline void akjFont::set_fontfilename(const char* value) {
  set_has_fontfilename();
  if (fontfilename_ == &::google::protobuf::internal::kEmptyString) {
    fontfilename_ = new ::std::string;
  }
  fontfilename_->assign(value);
}
inline void akjFont::set_fontfilename(const char* value, size_t size) {
  set_has_fontfilename();
  if (fontfilename_ == &::google::protobuf::internal::kEmptyString) {
    fontfilename_ = new ::std::string;
  }
  fontfilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* akjFont::mutable_fontfilename() {
  set_has_fontfilename();
  if (fontfilename_ == &::google::protobuf::internal::kEmptyString) {
    fontfilename_ = new ::std::string;
  }
  return fontfilename_;
}
inline ::std::string* akjFont::release_fontfilename() {
  clear_has_fontfilename();
  if (fontfilename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fontfilename_;
    fontfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void akjFont::set_allocated_fontfilename(::std::string* fontfilename) {
  if (fontfilename_ != &::google::protobuf::internal::kEmptyString) {
    delete fontfilename_;
  }
  if (fontfilename) {
    set_has_fontfilename();
    fontfilename_ = fontfilename;
  } else {
    clear_has_fontfilename();
    fontfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 texWidth = 3;
inline bool akjFont::has_texwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void akjFont::set_has_texwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void akjFont::clear_has_texwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void akjFont::clear_texwidth() {
  texwidth_ = 0;
  clear_has_texwidth();
}
inline ::google::protobuf::int32 akjFont::texwidth() const {
  return texwidth_;
}
inline void akjFont::set_texwidth(::google::protobuf::int32 value) {
  set_has_texwidth();
  texwidth_ = value;
}

// optional int32 texHeight = 4;
inline bool akjFont::has_texheight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void akjFont::set_has_texheight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void akjFont::clear_has_texheight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void akjFont::clear_texheight() {
  texheight_ = 0;
  clear_has_texheight();
}
inline ::google::protobuf::int32 akjFont::texheight() const {
  return texheight_;
}
inline void akjFont::set_texheight(::google::protobuf::int32 value) {
  set_has_texheight();
  texheight_ = value;
}

// optional sint32 offset = 5;
inline bool akjFont::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void akjFont::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void akjFont::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void akjFont::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 akjFont::offset() const {
  return offset_;
}
inline void akjFont::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// optional float scaleFactor = 6;
inline bool akjFont::has_scalefactor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void akjFont::set_has_scalefactor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void akjFont::clear_has_scalefactor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void akjFont::clear_scalefactor() {
  scalefactor_ = 0;
  clear_has_scalefactor();
}
inline float akjFont::scalefactor() const {
  return scalefactor_;
}
inline void akjFont::set_scalefactor(float value) {
  set_has_scalefactor();
  scalefactor_ = value;
}

// repeated .sdff.akjFont.charData chars = 7;
inline int akjFont::chars_size() const {
  return chars_.size();
}
inline void akjFont::clear_chars() {
  chars_.Clear();
}
inline const ::sdff::akjFont_charData& akjFont::chars(int index) const {
  return chars_.Get(index);
}
inline ::sdff::akjFont_charData* akjFont::mutable_chars(int index) {
  return chars_.Mutable(index);
}
inline ::sdff::akjFont_charData* akjFont::add_chars() {
  return chars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_charData >&
akjFont::chars() const {
  return chars_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_charData >*
akjFont::mutable_chars() {
  return &chars_;
}

// repeated .sdff.akjFont.vertexData vertices = 8;
inline int akjFont::vertices_size() const {
  return vertices_.size();
}
inline void akjFont::clear_vertices() {
  vertices_.Clear();
}
inline const ::sdff::akjFont_vertexData& akjFont::vertices(int index) const {
  return vertices_.Get(index);
}
inline ::sdff::akjFont_vertexData* akjFont::mutable_vertices(int index) {
  return vertices_.Mutable(index);
}
inline ::sdff::akjFont_vertexData* akjFont::add_vertices() {
  return vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_vertexData >&
akjFont::vertices() const {
  return vertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_vertexData >*
akjFont::mutable_vertices() {
  return &vertices_;
}

// repeated .sdff.akjFont.kernData kernPairs = 9;
inline int akjFont::kernpairs_size() const {
  return kernpairs_.size();
}
inline void akjFont::clear_kernpairs() {
  kernpairs_.Clear();
}
inline const ::sdff::akjFont_kernData& akjFont::kernpairs(int index) const {
  return kernpairs_.Get(index);
}
inline ::sdff::akjFont_kernData* akjFont::mutable_kernpairs(int index) {
  return kernpairs_.Mutable(index);
}
inline ::sdff::akjFont_kernData* akjFont::add_kernpairs() {
  return kernpairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_kernData >&
akjFont::kernpairs() const {
  return kernpairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::sdff::akjFont_kernData >*
akjFont::mutable_kernpairs() {
  return &kernpairs_;
}

// optional bytes ddsData = 10;
inline bool akjFont::has_ddsdata() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void akjFont::set_has_ddsdata() {
  _has_bits_[0] |= 0x00000200u;
}
inline void akjFont::clear_has_ddsdata() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void akjFont::clear_ddsdata() {
  if (ddsdata_ != &::google::protobuf::internal::kEmptyString) {
    ddsdata_->clear();
  }
  clear_has_ddsdata();
}
inline const ::std::string& akjFont::ddsdata() const {
  return *ddsdata_;
}
inline void akjFont::set_ddsdata(const ::std::string& value) {
  set_has_ddsdata();
  if (ddsdata_ == &::google::protobuf::internal::kEmptyString) {
    ddsdata_ = new ::std::string;
  }
  ddsdata_->assign(value);
}
inline void akjFont::set_ddsdata(const char* value) {
  set_has_ddsdata();
  if (ddsdata_ == &::google::protobuf::internal::kEmptyString) {
    ddsdata_ = new ::std::string;
  }
  ddsdata_->assign(value);
}
inline void akjFont::set_ddsdata(const void* value, size_t size) {
  set_has_ddsdata();
  if (ddsdata_ == &::google::protobuf::internal::kEmptyString) {
    ddsdata_ = new ::std::string;
  }
  ddsdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* akjFont::mutable_ddsdata() {
  set_has_ddsdata();
  if (ddsdata_ == &::google::protobuf::internal::kEmptyString) {
    ddsdata_ = new ::std::string;
  }
  return ddsdata_;
}
inline ::std::string* akjFont::release_ddsdata() {
  clear_has_ddsdata();
  if (ddsdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ddsdata_;
    ddsdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void akjFont::set_allocated_ddsdata(::std::string* ddsdata) {
  if (ddsdata_ != &::google::protobuf::internal::kEmptyString) {
    delete ddsdata_;
  }
  if (ddsdata) {
    set_has_ddsdata();
    ddsdata_ = ddsdata;
  } else {
    clear_has_ddsdata();
    ddsdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fontFileData = 11;
inline bool akjFont::has_fontfiledata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void akjFont::set_has_fontfiledata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void akjFont::clear_has_fontfiledata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void akjFont::clear_fontfiledata() {
  if (fontfiledata_ != &::google::protobuf::internal::kEmptyString) {
    fontfiledata_->clear();
  }
  clear_has_fontfiledata();
}
inline const ::std::string& akjFont::fontfiledata() const {
  return *fontfiledata_;
}
inline void akjFont::set_fontfiledata(const ::std::string& value) {
  set_has_fontfiledata();
  if (fontfiledata_ == &::google::protobuf::internal::kEmptyString) {
    fontfiledata_ = new ::std::string;
  }
  fontfiledata_->assign(value);
}
inline void akjFont::set_fontfiledata(const char* value) {
  set_has_fontfiledata();
  if (fontfiledata_ == &::google::protobuf::internal::kEmptyString) {
    fontfiledata_ = new ::std::string;
  }
  fontfiledata_->assign(value);
}
inline void akjFont::set_fontfiledata(const void* value, size_t size) {
  set_has_fontfiledata();
  if (fontfiledata_ == &::google::protobuf::internal::kEmptyString) {
    fontfiledata_ = new ::std::string;
  }
  fontfiledata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* akjFont::mutable_fontfiledata() {
  set_has_fontfiledata();
  if (fontfiledata_ == &::google::protobuf::internal::kEmptyString) {
    fontfiledata_ = new ::std::string;
  }
  return fontfiledata_;
}
inline ::std::string* akjFont::release_fontfiledata() {
  clear_has_fontfiledata();
  if (fontfiledata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fontfiledata_;
    fontfiledata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void akjFont::set_allocated_fontfiledata(::std::string* fontfiledata) {
  if (fontfiledata_ != &::google::protobuf::internal::kEmptyString) {
    delete fontfiledata_;
  }
  if (fontfiledata) {
    set_has_fontfiledata();
    fontfiledata_ = fontfiledata;
  } else {
    clear_has_fontfiledata();
    fontfiledata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sdff

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_akjFont_2eproto__INCLUDED
